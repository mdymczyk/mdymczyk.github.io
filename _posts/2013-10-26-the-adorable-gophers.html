---
layout: post
title: The adorable GOphers
date: '2013-10-26T09:55:00.000-07:00'
author: Mateusz
tags: 
modified_time: '2013-10-26T09:55:05.864-07:00'
blogger_id: tag:blogger.com,1999:blog-991896912459709097.post-3354585079476266360
blogger_orig_url: http://www.puroguramingu.com/2013/10/the-adorable-gophers.html
---

<p>Last Thursday I had the pleasure of attending Andrew Gerrand's code lab "Whispering Gophers: networking programming in Go" here in Tokyo. Why is that so fascinating? Well mainly because I think it's a really cool code lab if you want to see what Go can actually do <b>and</b> everyone can give it a try. But about that later.</p> <p>So what is Go and why should you care? According to <a href="http://golang.org/">the official website</a>:</p> <blockquote><i>Go is an open source programming environment that makes it easy to build simple, reliable, and efficient software.</i></blockquote> <p>That's pretty generic description so let's expand it:</p> <ul><li>was developed at Google in 2007 as an internal language by Robert Griesemer, Rob Pike, and Ken Thompson (yes <b><i>that</i></b> Ken Thompson)</li><li>Go is statically-typed (although it does look dynamic at places thanks to a basic type inferencing system)</li><li>has C-style syntax <b>but</b> with some (minor) <a href="http://blog.golang.org/gos-declaration-syntax">fundamental differences</a></li><li>contrary to C uses automatic memory management</li><li>is compiled (but compilation time shouldn't be a concern. Runtime speed, though, is a completely different story)</li></ul> <p>So is that all? No! There's much more to it. Some random features that <b>I</b> personally found interesting include:</p> <h3>Visibility</h3> <p>If you're a C++/Java/C# guy or into a language that has some kind of visibility mechanism like public/protected/package/private you will be surprise that Go does not uses that kind of stuff! Instead visibility in Go is by default at the package level. What to do when you want something to be visible from outside of the package? Uppercase it! That is exactly why this will work:</p> <pre class="brush: cpp"><br />package main<br />import "fmt"<br /><br />func main() {<br />    fmt.Println("Hello, 世界")<br />}<br /></pre> <p>And this will fail:</p> <pre class="brush: cpp"><br />package main<br />import "fmt"<br /><br />func main() {<br />    fmt.println("Hello, 世界")<br />}<br /></pre> <p>At this point all the purity nerds are probably going crazy "how can this be, exposing my internals to the world is worse than killing kittens!". Well, no. At least not for me! Over the years I come to realise that it does not matter whether you call something directly or using a method as long as it's all within your code! External API is a obviously completely different but first of all external APIs are much more rare than internal code and second of all for that you have the uppercase convention. Pretty cool little feature that wouldn't make me generate getters and setters all over my code (although indeed in Java this isn't so troublesome nowadays thanks to IDEs and stuff like <a href="http://projectlombok.org/">Project Lombok</a>).  <h3>Goroutines and channels</h3> <p>If you have worked with multithreaded code in the past chances are that you hated it as much as I do. At least that's the case for most popular programming languages. The boilerplate around it is, usually, just too annoying. Go, though, shines in this regard with it's inbuilt light threads called <b>Goroutines</b> and with the mechanism that let's different goroutines communicate <b>channels</b>. Channels are the only way goroutines can communicate between eachother. You don't get any handle or pointer to a goroutine when you create it. Ok but how do you actually spawn a new thread of execution?</p> <pre class="brush: cpp"><br />package main<br />import "fmt"<br /><br />func myFunction() {<br />  for i := 0; i < 5; i++ {<br />    fmt.println("Woohoo, I'm in a different thread!")<br />  }<br />}<br /><br />func main() {<br />  go myFunction()<br />  for i := 0; i < 5; i++ {  <br />    fmt.println("Main thread calling!")<br />  }<br />}<br /></pre> <p>The code above will make <b>myFunction</b> to run in concurrently thanks to the use of the <b>go</b> keyword! That's really all you need to do! If you would like to communicate between those two you would just need to create a channel:</p> <pre class="brush: cpp"><br />func compute(channel chan uint64) {<br />   // do some time consuming computation and put the result to "res"<br />   channel <- res;<br />}<br /><br />func UseAGoroutine() {<br />  channel := make(chan uint64);<br />  go compute(channel);<br />  // mind your own business while compute() runs in a different thread<br />  computed := <- channel;<br />  // use the computed result in this thread!<br />}<br /></pre> <p>Is that easy or is that easy? Actually the above code can be made even more concise since Go supports anonymous functions and has lexical-scope for variables but I will leave that out for now. The best part here is that they are truly lightweight so you don't have to worry too much about overusing them as they will be properly mapped to OS threads.</p> <h3>Utilities!</h3> <p>My take on Go is that it's trying to be a very modern language which tries to address all the problems development <b>teams</b> had over the years. "Teams" is very important here, people who all their lives programmed by themselves might not appreciate things like:</p> <ul><li><b>go fmt</b> - this little thing will format your code according to the standard! Yes, IDEs do that also but usually you need to define all the rules yourself. Yes Python has something very similar with it's indentation system and... Well that's one of the reasons I love Python! Despite what anyone can tell you having a concise code is much more important than having this brace here and this brace here just because <b>you</b> like it that way. Repetitiveness here is good as it speeds up the time you need to read the code!</li><li><b>go test</b> - yup, Go has a testing feature right out of the box! It definitely isn't the best thing out there, but it's still cool that it's part of the language itself</li><li>Go highly recommends creating an environment variable $GOPATH and putting all your projects in $GOPATH/src/mylittleproject/. Why is this cool? Because Go has native support for version control systems! Let's say you have your project on GitHub and want to download it, what do you do? You just execute <b>go get github.com/user/mylittleproject/</b>. That's a pretty neat little feature right that</li><li>Deployment! I don't know about you but in my life deploying things was always a nightmare. Whenever I had to do a deploy I was sure there will be some magical scripts etc. involved. In Go the result of compilation is a single binary file so it all boils down to cross-compiling your project and simply deploying it where you want. No need for external dependencies!</li></ul> <p>There is obviously much, much more good things I didn't mention here. But I'm pretty sure that once you start reading the materials I will post at the end of this post you'll find about them.  <h3>The reality slap</h3> <p>So is Go the best thing ever since <a href="http://www.youtube.com/watch?v=tgbNymZ7vqY">The Muppets: Bohemian Rhapsody</a>? Well, unfortunately, not quite! The list of things <b>I</b> don't like in Go goes on and on...  <ul><li>the name. Seriously, please don't call things like "D", "Go" or whatever. It's a pain in the you know what to find information about such technologies! In case of Go there's actually already a different language called Go!...</li><li>global state - yes, you can use global state in Go! You can try, but you will not convince me that it is a good thing</li><li>lack of exceptions - well this isn't 100% true as there is <b>panic</b> which basically works like exceptions. The thing is you shouldn't really use it, from my understanding. As a result you end up returning the, instead of your normal result, an <b>error</b> objects which then you can use to check if everything went ok. Before I noticed I ended up repeating the same piece of code all over the place (which to say the least wasn't neither pleasant nor good for the codebase):</li><pre class="brush: cpp"><br />v, err = something.SomethingThatMightReturnAnError()<br />if err != nil {<br />  //handle me like one of your French exceptions<br />}<br /></pre><li>everything is an error. On would think that this is good, because the creators are strict but seeing how they are inconsistent at times themselves (for instance the above error mechanism can be silenced like it is in the case of fmt.Println which does return an error object!) and how really annoying this is during development I'd really appreciate being able to make it less strict. Now even unused imports/variables will make your code fail</li><li>no generics - one would think "how is this possible in this day and age?" but that's the harsh reality. Go does not have generics! One might argue it's better to have no generics than to have stuff similar to Java's generics, but it's really painful to write code without them. So how do you write that generic <b>max(T el1, T el2)</b> method? You don't. You write a lot of them, one for each type! Ok I am not being 100% fair here because there are ways to go around this, fo instance using <b>interface{}</b> but it's not really the most pleasant way out!</li><li>because of the things I mentioned above and some other reasons it simply does not feel DRY enough and the last thing I want in my codebase is repetitive code</li><li>it has pointer. Ok this is more of a joke but I do have nightmares where I am back at Uni and take my C class</li></ul> <h3>So in the end...?</h3> <p>It's been already 6 years since Go was created and it still didn't get that much traction. Yes, yes according to some articles etc. it did get the most users in X amount of time blah blah blah but still almost no one knows about it and even less people are using it!  Still, I encourage you to check it out. Especially if you're looking for something between C and Java and/or want to develop highly concurrent apps! You might not be disappointed!  How to start?</p> <ol><li><a href="http://tour.golang.org/#1">A tour of Go</a> will get you started with the basic syntax and constructs</li><li><a href="http://golang.org/ref/spec">The spec</a> will comfort you when you're sad</li><li>As I mentioned <a href="https://code.google.com/p/whispering-gophers/">the whispering gophers</a> code lab is available online for everyone! The slides will take you step by step through setting up your machine, getting the necessary code and every single exercise. It's a great place to learn about goroutines, channels and how a basic gossip protocol works!</li><li>You might or not be aware of this but MIT (yes, <b>the MIT</b>) rewrote it's whole <a href="http://pdos.csail.mit.edu/6.824/">6.824: Distributed Systems</a> lab in Go! After finishing the above materials dive into the wonderful world of <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos</a> based sharded key-value stores in Go! Personally I did only the first two labs but they were more than worth it and I'm really tempted to finish the remaining 3</li></ol> <p>As always I'm looking forward to hearing your feedback, especially if you used Go in production!</p>